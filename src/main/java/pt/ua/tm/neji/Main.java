package pt.ua.tm.neji;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.File;
import java.io.OutputStream;
import java.io.PrintStream;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.GnuParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pt.ua.tm.gimli.config.Constants;
import pt.ua.tm.neji.batch.Batch;
import pt.ua.tm.neji.context.Context;
import pt.ua.tm.neji.main.Processor;
import pt.ua.tm.neji.ml.MLModel;

/**
 *
 * @author david
 */
public class Main {

    /**
     * {@link Logger} to be used in the class.
     */
    private static Logger logger = LoggerFactory.getLogger(Main.class);

    /**
     * Print help message of the program.
     *
     * @param options Command line arguments.
     * @param msg Message to be displayed.
     */
    private static void printHelp(final Options options, final String msg) {
        logger.error(msg);
        HelpFormatter formatter = new HelpFormatter();
        formatter.printHelp("java -cp gimli.jar pt.ua.tm.gimli.PubmedBatch", options);
    }
    /**
     * Help message.
     */
    private static final String MODEL_HELP = "Please follow the format: [file],[group],[config],[parsing],[lexicons]\n"
            + "-file: File with model;\n"
            + "-group: Semantic group of the annotations generated by the model;\n"
            + "-config: File with features configuration;\n"
            + "-parsing: fw (forward) or bw (backward);\n"
            + "-lexicons: Folder that contains the lexicons to perform normalization (optional).";

    public static enum InputFormat {

        XML, RAW
    };

    public static enum OutputFormat {

        A1, NEJI, JSON, CONLL, XML
    };

    public static void main(String[] args) {

        int NUM_THREADS = Runtime.getRuntime().availableProcessors() - 1;
        NUM_THREADS = NUM_THREADS > 0 ? NUM_THREADS : 1;


        CommandLineParser parser = new GnuParser();
        Options options = new Options();
        options.addOption("h", "help", false, "Print this usage information.");

        options.addOption("i", "input", true, "Folder with corpus files.");
        options.addOption("o", "output", true, "Folder to save the annotated corpus files.");

        Option o = new Option("m", "models", true, MODEL_HELP);
        o.setArgs(Integer.MAX_VALUE);
        options.addOption(o);

        options.addOption("d", "dictionaires", true, "Folder that contains the dictionaries.");

        options.addOption("if", "input format", true, "XML or RAW");
        options.addOption("of", "output format", true, "A1, NEJI, JSON, CONLL or IEXML");

        options.addOption("x", "XML tags", true, "XML tags to be considered.");

        options.addOption("v", "verbose", false, "Verbose mode.");

        options.addOption("c", "compressed", false, "If files are compressed using GZip.");

        options.addOption("t", "threads", true, "Number of threads. By default, if more than one core is available, it is the number of cores minus 1.");

        CommandLine commandLine = null;
        try {
            // Parse the program arguments
            commandLine = parser.parse(options, args);
        } catch (ParseException ex) {
            logger.error("There was a problem processing the input arguments.", ex);
            return;
        }

        // Show help text
        if (commandLine.hasOption('h')) {
            printHelp(options, "");
            return;
        }

        File test = null;
        // Get corpus folder for input
        String folderCorpusIn = null;
        if (commandLine.hasOption('i')) {
            folderCorpusIn = commandLine.getOptionValue('i');
        } else {
            printHelp(options, "Please specify the input corpus folder.");
            return;
        }
        test = new File(folderCorpusIn);
        if (!test.isDirectory() || !test.canRead()) {
            logger.error("The specified path is not a folder or is not readable.");
            return;
        }

        // Get Input format
        InputFormat inputFormat;
        if (commandLine.hasOption("if")) {
            inputFormat = InputFormat.valueOf(commandLine.getOptionValue("if"));
        } else {
            printHelp(options, "Please specify the input format.");
            return;
        }

        // Get corpus folder for output
        String folderCorpusOut = null;
        if (commandLine.hasOption('o')) {
            folderCorpusOut = commandLine.getOptionValue('o');
        } else {
            printHelp(options, "Please specify the output corpus folder.");
            return;
        }
        test = new File(folderCorpusOut);
        if (!test.isDirectory() || !test.canWrite()) {
            logger.error("The specified path is not a folder or is not writable.");
            return;
        }

        // Get Output format
        OutputFormat outputFormat;
        if (commandLine.hasOption("of")) {
            outputFormat = OutputFormat.valueOf(commandLine.getOptionValue("of"));
        } else {
            printHelp(options, "Please specify the output format.");
            return;
        }

        if (inputFormat.equals(InputFormat.XML)) {
            if (outputFormat.equals(OutputFormat.A1) || outputFormat.equals(OutputFormat.JSON) || outputFormat.equals(OutputFormat.NEJI)) {
                logger.error("XML input format only supports XML and CoNLL output formats, since other formats are based on character positions.");
                return;
            }
        }

        // Get XML tags
        String[] xmlTags = null;
        if (inputFormat.equals(InputFormat.XML)) {
            if (commandLine.hasOption("x")) {
                xmlTags = commandLine.getOptionValue("x").split(",");
            } else {
                printHelp(options, "Please specify XML tags to be used.");
                return;
            }
        }

        // Get models
        boolean doModels;
        String[] input = null;
        if (commandLine.hasOption('m')) {
            input = commandLine.getOptionValues('m');
            doModels = true;
        } else {
            doModels = false;
        }

        String[] models = null;
        String[] groups = null;
        String[] configs = null;
        Constants.Parsing[] parsings = null;
        String[] normalization = null;

        if (doModels) {
            models = new String[input.length];
            groups = new String[input.length];
            configs = new String[input.length];
            parsings = new Constants.Parsing[input.length];
            normalization = new String[input.length];

            String[] strs;
            for (int i = 0; i < input.length; i++) {
                strs = input[i].split(",");

                if (strs.length != 4 && strs.length != 5) {
                    printHelp(options, "Wrong input format for models.");
                    return;
                }

                models[i] = strs[0].trim();
                groups[i] = strs[1].trim();
                configs[i] = strs[2].trim();
                parsings[i] = Constants.Parsing.valueOf(strs[3].trim().toUpperCase());

                if (strs.length == 5) {
                    normalization[i] = strs[4].trim();
                }
            }
        }


        // Get dictionaries folder
        boolean doDictionaries = false;
        String dictionariesFolder = null;
        if (commandLine.hasOption('d')) {
            dictionariesFolder = commandLine.getOptionValue('d');
            doDictionaries = true;

            test = new File(dictionariesFolder);
            if (!test.isDirectory() || !test.canRead()) {
                logger.error("The specified path is not a folder or is not readable.");
                return;
            }
        }

        // Get verbose mode
        boolean verbose = false;
        if (commandLine.hasOption('v')) {
            verbose = true;
        }
        Constants.verbose = verbose;

        // Disable output from Mallet and GDep
        if (!Constants.verbose) {
            System.setOut(new PrintStream(new OutputStream() {
                @Override
                public void write(int b) {
                }
            }));
            System.setErr(new PrintStream(new OutputStream() {
                @Override
                public void write(int b) {
                }
            }));
        }

        // Get verbose mode
        boolean compressed = false;
        if (commandLine.hasOption('c')) {
            compressed = true;
        }

        // Get threads
        String threadsText = null;
        if (commandLine.hasOption('t')) {
            threadsText = commandLine.getOptionValue('t');
            NUM_THREADS = Integer.parseInt(threadsText);
            if (NUM_THREADS <= 0 || NUM_THREADS > 32) {
                logger.error("Illegal number of threads. Must be between 1 and 32.");
                return;
            }
        }


        MLModel[] mlmodels = new MLModel[0];
        if (doModels) {
            mlmodels = new MLModel[models.length];
            for (int i = 0; i < mlmodels.length; i++) {
                mlmodels[i] = new MLModel(models[i], configs[i], parsings[i], groups[i], normalization[i]);
            }
        }


        Context context = new Context(
                mlmodels, // Models
                dictionariesFolder, // Dictionaries folder
                false); // Use LINNAEUS    

        try {

            Batch batch = new Batch(folderCorpusIn, folderCorpusOut, compressed, NUM_THREADS);

            if (inputFormat.equals(InputFormat.XML)) {
                batch.run(Processor.class, context, inputFormat, outputFormat, xmlTags);
            } else {
                batch.run(Processor.class, context, inputFormat, outputFormat);
            }

        } catch (Exception ex) {
            logger.error("There was a problem adding running the batch.", ex);
            return;
        }

        System.exit(0);

    }
}
